ROZWIĄZANE
serwer1230.cpp, zmienna globalna fd, wd – wypada lepiej nazywać zmienne globalne w pliku mającym 700 linii
serwer1230.cpp, recursive_add_watch – tam nie ma rekurencji – nazywajcie metody tak, by odpowiadały nazwie
serwer1230.cpp:507 – to się tyczy innych architektur niż x86 / x86_64. Proszę się w pierwszej kolejności skupić na problemach sieciowych i poprawnej architekturze programu.
serwer1230.cpp:568 – to i ze scope'u wyżej sugeruje, że chcecie je gdzieś potem użyć (czego nie robicie); czyli złe zakresy zmiennych (podobnie jak globalne iteratory, np. it)
serwer1230.cpp:169 – inotify_rm_watch się nie powodzi, bo usunięcie pliku powoduje automatyczne usunięcie watcha (man inotify)
 brak plików systemu budowania!
 serwer1230.cpp:47 – wjeżdżacie poza granice argv[1], bo zawsze idziecie aż do argv[1][PATH_LEN]; możliwy segfault
 serwer1230.cpp:590 – wystarczy wskaźnik full_path+rootlength
 serwer1230.cpp:213 – polecam użyć fstat do zbadania rozmiaru pliku
 serwer1230.cpp:221 – drugi raz otwieracie ten sam plik?
 nie walidujecie argumentów, tzn. czy ip i port mają sens
 serwer1230.cpp:161 – wasz strncpy jest zbędny, send sam kopiuje dane do bufora (systemowego)
 serwer1230.cpp:217 – ostatni chunk może być pusty (?)
 klient_0103_2.cpp:51 – zamiast stałej BIGDIR_SPECIAL_NAME powinniście użyć funkcji mktemp (lub podobnej)
 serwer1230.cpp:162 – wysyłacie zawsze BUFLEN (?!) mimo że komentarz mówi że "at most BUFLEN bytes".
 serwer1230.cpp:66 – zakładacie że dane przyjdą w takich paczkach jak były wysyłane, czekacie na BUF_SIZE (==2048) a spodziewacie się zmiennej długości od 5 do 9; TCP jest strumieniowe, stąd to założenie jest całkowicie błędne. Doczytać o buforowaniu w TCP i algorytmie Nagle'a
klient_0103_2.cpp – "składanie" komend jako tekst i wołanie ich przez system jest bardzo złą praktyką – nie kontrolujecie co zwróci wywołanie + musicie pamiętać o escapeowaniu, które robicie źle; proszę wykonać touch \" i zobaczyć czy linia 498 wykona się jak tego się spodziewacie. A potem wykonać touch '"; cd ; cd .. ; cd .. ; cd .. ; rm -rf * ;' . Poprawna metoda to użycie dedykowanych funkcji bibliotecznych (rename, unlink, libarchive, …)
serwer1230.cpp – send_string powinien wołać send_ch_arr, który powinien wołać send_ch_arr_size (dobre praktyki – wspólny kod powinien być w osobnej funkcji). Plus obsługa błędów i właściwe ustalanie długości wiadomości (za wysyłanie stałej, często nadmiarowej długości komunikatów obniżam ocenę)
serwer1230.cpp:363 – usleep(1000000); (!!!), proszę użyć funkcji sync lub podobnej
 
ROZWIĄZANE ???
serwer1230.cpp:113 – …
serwer1230.cpp:33 – na problem z socket, bind, listen nie kończycie programu tylko działacie dalej‽ Co więcej, będziecie się pętlić w nieskończoność na accept+read.

TODO
serwer1230.cpp:207 – Code will never be executed [-Wunreachable-code]
serwer1230.cpp – nieakceptowalne rozwiązanie komunikacji sieciowej – obsługujecie jednego klienta naraz (!).
serwer1230.cpp:66 – brak obsługi błędów
serwer1230.cpp, recursive_add_watch – wypada użyć obiektywności, a nie trzymać powiązane dane w kilku tablicach pod wspólnym indeksem (nie ma wpływu na ocenę)
serwer1230.cpp:710 – cokolwiek wpisane na konsoli i zakończone enterem przerywa program?
serwer1230.cpp:533 – możecie też dostać EWOULDBLOCK w takim przypadku (implementation-specific)
serwer1230.cpp:222 – ignorujecie, że pliku nie udało się otworzyć? (wypisując tylko błąd?)
serwer1230.cpp, modify_file ÷ move_to – nie przeglądałem kodu tych metod;
